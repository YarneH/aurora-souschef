package com.aurora.souschef;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.content.ContextCompat;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.util.Log;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.aurora.souschef.utilities.StringUtilities;
import com.aurora.souschefprocessor.recipe.ListIngredient;
import com.aurora.souschefprocessor.recipe.Recipe;
import com.aurora.souschefprocessor.recipe.RecipeTimer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StepPlaceholderFragment extends Fragment {
    /**
     * The fragment argument representing the section number for this
     * fragment.
     */
    private static final String ARG_SECTION_NUMBER = "section_number";
    private static int mAmountSteps = 0;
    private static Recipe mRecipe = null;
    private static String[] mDescriptionSteps = null;
    private List<ListIngredient> mStepIngredients = null;
    private ArrayList<TextView> mStepDescriptionParts = new ArrayList<>();
    private ArrayList<Integer> mStepPositions = new ArrayList<>();
    private ArrayList<Integer> mQuantityPositions = new ArrayList<>();
    private ArrayList<Integer> mQuantityLengths = new ArrayList<>();


    public StepPlaceholderFragment() {
        // Empty constructor (generated by Android Studio)
    }

    /**
     * Returns a new instance of this fragment for the given section
     * number.
     */
    public static StepPlaceholderFragment newInstance(Recipe recipe, int sectionNumber, int amountSteps) {
        StepPlaceholderFragment fragment = new StepPlaceholderFragment();
        fragment.mAmountSteps = amountSteps;
        Bundle args = new Bundle();
        args.putInt(ARG_SECTION_NUMBER, sectionNumber);
        mRecipe = recipe;

        int stepsCount = mRecipe.getRecipeSteps().size();
        mDescriptionSteps = new String[stepsCount];

        for (int i = 0; i < stepsCount; i++) {
            mDescriptionSteps[i] = mRecipe.getRecipeSteps().get(i).getDescription();
        }

        fragment.setArguments(args);
        Collections.sort(mRecipe.getIngredients(), (l0, l1) ->
                l0.getQuantityPosition().getBeginIndex() - l1.getQuantityPosition().getBeginIndex());
        return fragment;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        int index = getArguments().getInt(ARG_SECTION_NUMBER);

        // Inflate the CardView and get the View
        View rootView = inflater.inflate(R.layout.fragment_steps, container, false);
        TextView titleTextView = (TextView) rootView.findViewById(R.id.tv_title);

        // Set the title
        titleTextView.setText(getString(R.string.section_format, index + 1));

        // Add the separate TextViews and TimerCards
        addTextAndTimers(inflater, rootView, index);

        // Setup the RecyclerView of the ingredients
        RecyclerView mIngredientList = rootView.findViewById(R.id.rv_ingredient_list);
        mIngredientList.setLayoutManager(new LinearLayoutManager(this.getContext()));

        // Feed Adapter
        StepIngredientAdapter ingredientAdapter =
                new StepIngredientAdapter(mRecipe.getRecipeSteps().get(index).getIngredients());
        mIngredientList.setAdapter(ingredientAdapter);

        // Disable the line if there are no ingredients listed
        if (mRecipe.getRecipeSteps().get(index).getIngredients().size() == 0) {
            rootView.findViewById(R.id.v_line).setVisibility(View.GONE);
        }

        // Disable OVER_SCROLL effect (scrollbar is always visible, so effect not needed)
        mIngredientList.setOverScrollMode(View.OVER_SCROLL_NEVER);
        rootView.findViewById(R.id.sv_text_and_timers).setOverScrollMode(View.OVER_SCROLL_NEVER);

        // Add the ImageViews to the LinearLayout for the indicator dots
        int dots_margin = Math.round(getResources().getDimension(R.dimen.dots_margin));
        LinearLayout linearLayout = (LinearLayout) rootView.findViewById(R.id.ll_dots);
        ImageView tempView;
        LinearLayout.LayoutParams layoutParamsDot = new LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        layoutParamsDot.setMargins(dots_margin, dots_margin,
                dots_margin, dots_margin);

        // For every step, add a dot and make sure the right one is selected
        for (int i = 0; i < mAmountSteps; i++) {
            tempView = (ImageView) inflater.inflate(R.layout.dot_image_view, null);
            if (i == index) {
                tempView.setBackground(ContextCompat.getDrawable(getContext(), R.drawable.selected_dot));
            } else {
                tempView.setBackground(ContextCompat.getDrawable(getContext(), R.drawable.not_selected_dot));
            }
            tempView.setLayoutParams(layoutParamsDot);
            linearLayout.addView(tempView);
        }
        return rootView;
    }

    private void addTextAndTimers(LayoutInflater inflater, View rootView, int index) {
        // Add a zero to the positions of the parts
        mStepPositions.add(0);

        // Add the positions of ingredients to the list
        for (ListIngredient ingredient : mRecipe.getIngredients()) {
            mQuantityPositions.add(ingredient.getQuantityPosition().getBeginIndex());
            int quantityLength = ingredient.getQuantityPosition().getEndIndex() -
                    ingredient.getQuantityPosition().getBeginIndex();
            mQuantityLengths.add(quantityLength);
        }

        // Add Text and Timer
        int timerMargin = Math.round(getResources().getDimension(R.dimen.timer_margin));
        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        layoutParams.setMargins(0, timerMargin, 0, timerMargin);
        layoutParams.gravity = Gravity.CENTER;
        ViewGroup insertPoint = (ViewGroup) rootView.findViewById(R.id.ll_step);
        int currentPosition = 0;

        for (RecipeTimer timer : mRecipe.getRecipeSteps().get(index).getRecipeTimers()) {
            // Inflate the layout of a text and a timer
            View timerView = inflater.inflate(R.layout.timer_card, null);
            TextView textView = (TextView) inflater.inflate(R.layout.step_textview, null);

            // Set Text of the TextView
            int tempPosition = timer.getPosition().getEndIndex();
            String currentSubstring = mDescriptionSteps[index].substring(currentPosition, tempPosition);
            Pattern p = Pattern.compile("\\p{Alpha}");
            Matcher m = p.matcher(currentSubstring);
            if (m.find()) {
                textView.setText(currentSubstring.substring(m.start()));
            }

            // Create a UITimer and set its on click listeners
            UITimer uiTimer = new UITimer(timer, timerView.findViewById(R.id.tv_timer));
            uiTimer.setOnClickListeners();

            // Add the timer to the LinearLayout
            insertPoint.addView(textView, insertPoint.getChildCount(), layoutParams);
            insertPoint.addView(timerView, insertPoint.getChildCount(), layoutParams);

            // Add TextView to the list
            mStepDescriptionParts.add(textView);
            Log.d("Add TextView", "" + mStepDescriptionParts.size());
            mStepPositions.add(tempPosition);

            // Set the current position to the temporary position
            currentPosition = tempPosition;
        }

        // Check if there is still some text coming after the last timer
        if (currentPosition != mDescriptionSteps[index].length()) {
            TextView textView = (TextView) inflater.inflate(R.layout.step_textview, null);
            String currentSubstring = mDescriptionSteps[index].substring(currentPosition);
            Pattern p = Pattern.compile("\\p{Alpha}");
            Matcher m = p.matcher(mDescriptionSteps[index].substring(currentPosition));
            if (m.find()) {
                textView.setText(currentSubstring.substring(m.start()));
            }

            insertPoint.addView(textView, insertPoint.getChildCount(), layoutParams);
        }
    }

    protected void update(int newAmount) {
        // Keeps track of the changes in positions
        int offset = 0;

        for (int indexIngredient = 0; indexIngredient < mRecipe.getIngredients().size(); indexIngredient++) {
            ListIngredient ingredient = mRecipe.getIngredients().get(indexIngredient);
            boolean replaced = false;

            // Calculate the current length of the quantity
            int currentLength = ingredient.getQuantityPosition().getEndIndex() -
                    ingredient.getQuantityPosition().getBeginIndex();
            // Calculate the begin position considering the new offset which could be different from
            // zero when a previous ingredient had a different length
            int beginPosition = ingredient.getQuantityPosition().getBeginIndex() + offset;
            ingredient.getQuantityPosition().setBeginIndex(beginPosition);

            double newQuantity = ingredient.getValue() / mRecipe.getNumberOfPeople() * newAmount;
            String newQuantityString = StringUtilities.toDisplayQuantity(newQuantity);

            int newLength = newQuantityString.length();
            ingredient.getQuantityPosition().setEndIndex(beginPosition + newLength);


            for (int i = 0; i < mStepPositions.size() - 1; i++) {
                if (beginPosition < mStepPositions.get(i + 1) && !replaced) {

                    // Calculate the relative index
                    int relativeIndex = beginPosition - mStepPositions.get(i);

                    // Get old text and replace the old quantity with the new quantity
                    Log.d("Get Text", "i = " + i + " length of list = " + mStepDescriptionParts.size());
                    String currentText = String.valueOf(mStepDescriptionParts.get(i).getText());
                    StringBuilder builder = new StringBuilder(currentText);
                    builder.replace(relativeIndex, relativeIndex + currentLength, newQuantityString);
                    String newText = builder.toString();
                    mStepDescriptionParts.get(i).setText(newText);

                    // Update the offset and the 'replaced' boolean
                    offset = newLength - currentLength;
                    replaced = true;
                }
                mStepPositions.set(i, mStepPositions.get(i) + offset);
            }
        }
    }
}
