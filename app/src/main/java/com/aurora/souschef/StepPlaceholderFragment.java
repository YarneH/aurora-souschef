package com.aurora.souschef;

import android.arch.lifecycle.ViewModelProviders;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.content.ContextCompat;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.aurora.souschef.utilities.StringUtilities;
import com.aurora.souschefprocessor.recipe.Ingredient;
import com.aurora.souschefprocessor.recipe.Recipe;
import com.aurora.souschefprocessor.recipe.RecipeStep;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StepPlaceholderFragment extends Fragment {
    /**
     * The fragment argument representing the section number for this
     * fragment.
     */
    private static final String ARG_SECTION_NUMBER = "section_number";
    private View mRootView;
    private RecyclerView mIngredientList;
    private String[] mDescriptionStep;
    private int mAmountSteps = 0;
    private RecipeStep mRecipeStep = null;
    private int mOriginalAmount = 0;
    private int mCurrentAmount = 0;
    private List<Ingredient> mIngredientsForList = new ArrayList<>();
    private ArrayList<TextView> mStepDescriptionParts = new ArrayList<>();
    private ArrayList<Integer> mStepPositions = new ArrayList<>();
    private ArrayList<Integer> mQuantityPositions = new ArrayList<>();
    private ArrayList<Integer> mQuantityLengths = new ArrayList<>();


    public StepPlaceholderFragment() {
        // Empty constructor (generated by Android Studio)
    }

    /**
     * Returns a new instance of this fragment for the given section
     * number.
     */
    public static StepPlaceholderFragment newInstance(int sectionNumber) {
        StepPlaceholderFragment fragment = new StepPlaceholderFragment();
        Bundle args = new Bundle();
        args.putInt(ARG_SECTION_NUMBER, sectionNumber);

        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        int index = Objects.requireNonNull(getArguments()).getInt(ARG_SECTION_NUMBER);

        // Inflate a CardView with a step and get the View
        mRootView = inflater.inflate(R.layout.fragment_steps, container, false);
        TextView titleTextView = mRootView.findViewById(R.id.tv_title);

        // Set the TextViews
        titleTextView.setText(getString(R.string.section_format, index + 1));

        RecipeViewModel recipeViewModel = ViewModelProviders
                .of(Objects.requireNonNull(getActivity()))
                .get(RecipeViewModel.class);
        recipeViewModel.getRecipe().observe(this, (Recipe recipe) ->
                this.onNewRecipeObserved(inflater, container, recipe, index));
        recipeViewModel.getNumberOfPeople().observe(this, aInteger -> update(aInteger));

        return mRootView;
    }

    /**
     * Helper method called when a new recipe is observed
     *
     * @param inflater  Layout inflater to inflate necessary layouts
     * @param container ViewGroup to inflate in.
     * @param recipe    The observed recipe
     * @param index     The index of the step.
     */
    private void onNewRecipeObserved(LayoutInflater inflater, ViewGroup container, Recipe recipe, int index) {
        if (recipe == null) {
            return;
        }
        mDescriptionStep = extractDescriptionSteps(recipe);

        ViewGroup insertPoint = mRootView.findViewById(R.id.ll_step);

        RecipeTimerViewModel recipeTimerViewModel = ViewModelProviders
                .of(getActivity())
                .get(RecipeTimerViewModel.class);
        recipeTimerViewModel.init(recipe);

        mAmountSteps = recipe.getRecipeSteps().size();
        mOriginalAmount = recipe.getNumberOfPeople();
        mRecipeStep = recipe.getRecipeSteps().get(getArguments().getInt(ARG_SECTION_NUMBER));

        // Sort ingredients on descending beginIndex
        Collections.sort(mRecipeStep.getIngredients(), (l0, l1) ->
                l0.getQuantityPosition().getBeginIndex() + l1.getQuantityPosition().getBeginIndex());

        // Setup the RecyclerView of the ingredients
        mIngredientList = mRootView.findViewById(R.id.rv_ingredient_list);
        mIngredientList.setLayoutManager(new LinearLayoutManager(this.getContext()));

        // Feed Adapter
        StepIngredientAdapter ingredientAdapter =
                new StepIngredientAdapter(mRecipeStep.getIngredients(), recipe.getNumberOfPeople(), mCurrentAmount);
        mIngredientList.setAdapter(ingredientAdapter);

        // Disable the line if there are no ingredients listed
        if (mRecipeStep.getIngredients().size() == 0) {
            mRootView.findViewById(R.id.v_line).setVisibility(View.GONE);
        }

        // Disable OVER_SCROLL effect (scrollbar is always visible, so effect not needed)
        mIngredientList.setOverScrollMode(View.OVER_SCROLL_NEVER);
        mRootView.findViewById(R.id.sv_text_and_timers).setOverScrollMode(View.OVER_SCROLL_NEVER);

        // Keep index of the beginning of a text block to know where to cut the text.
        int beginOfTextBlock = 0;
        // Run over all timers to place them correctly.
        for (int i = 0; i < recipe.getRecipeSteps().get(index).getRecipeTimers().size(); i++) {
            // New card for the timer.
            View timerCard = inflater.inflate(R.layout.timer_card, container, false);
            // New TextView for the recipe description.
            TextView textView = (TextView) inflater.inflate(R.layout.step_textview, container, false);

            // Get timer data in this step of the i'th timer.
            LiveDataTimer liveDataTimer = recipeTimerViewModel.getTimerInStep(index, i);
            // Set the margin of the timer
            int timerMargin = Math.round(getResources().getDimension(R.dimen.timer_margin));
            LinearLayout.LayoutParams layoutParamsTimer = new LinearLayout.LayoutParams(
                    ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
            layoutParamsTimer.gravity = Gravity.CENTER;
            layoutParamsTimer.setMargins(0, timerMargin, 0, timerMargin);
            timerCard.setLayoutParams(layoutParamsTimer);
            // Make new timer-object. Is actually never used after this.
            new UITimer(liveDataTimer, timerCard, this);

            // Set TextViews
            // search for the next place to cut.
            int endOfTextBlock = recipe.getRecipeSteps()
                    .get(index).getRecipeTimers()
                    .get(i).getPosition()
                    .getEndIndex();
            // get the substring and place it in the TextView
            String currentSubstring = mDescriptionStep[index].substring(beginOfTextBlock, endOfTextBlock);
            Pattern p = Pattern.compile("\\p{Alpha}");
            Matcher m = p.matcher(currentSubstring);
            if (m.find()) {
                textView.setText(currentSubstring.substring(m.start()));
            }
            // Update the text-block start to be at the beginning of the next piece.
            beginOfTextBlock = endOfTextBlock;

            // Add text and timers to the parent.
            insertPoint.addView(textView);
            insertPoint.addView(timerCard);
        }
        // Check if there is still some text coming after the last timer
        // Repeat.
        if (beginOfTextBlock != mDescriptionStep[index].length()) {
            TextView textView = (TextView) inflater.inflate(R.layout.step_textview, container, false);
            String currentSubstring = mDescriptionStep[index].substring(beginOfTextBlock);
            Pattern p = Pattern.compile("\\p{Alpha}");
            Matcher m = p.matcher(mDescriptionStep[index].substring(beginOfTextBlock));
            if (m.find()) {
                textView.setText(currentSubstring.substring(m.start()));
            }
            insertPoint.addView(textView);
        }

        // Add dots
        this.addDots(inflater, recipe, index);
    }

    /**
     * Helper-class to add the navigation dots.
     *
     * @param inflater Layout inflater to inflate dot-views
     * @param recipe   used to get the amount of steps.
     * @param index    Index of the step, to see which dots to color.
     */
    private void addDots(LayoutInflater inflater, Recipe recipe, int index) {
        // Add the ImageViews to the LinearLayout for the indicator dots
        LinearLayout linearLayout = mRootView.findViewById(R.id.ll_dots);
        ImageView tempView;
        for (int i = 0; i < recipe.getRecipeSteps().size(); i++) {
            tempView = (ImageView) inflater.inflate(R.layout.dot_image_view, linearLayout, false);
            Drawable dot;
            if (i == index) {
                dot = ContextCompat.getDrawable(getContext(),
                        R.drawable.selected_dot);
            } else {
                dot = ContextCompat.getDrawable(getContext(),
                        R.drawable.not_selected_dot);
            }
            tempView.setImageDrawable(dot);
            linearLayout.addView(tempView);
        }
    }

    protected void update(int newAmount) {

        ((StepIngredientAdapter) mIngredientList.getAdapter()).setCurrentAmount(newAmount);
        mIngredientList.getAdapter().notifyDataSetChanged();


        StringBuilder bld = new StringBuilder(mRecipeStep.getDescription());

        for (Ingredient ingredient : mRecipeStep.getIngredients()){
            if (ingredient.getQuantityPosition().getBeginIndex() != 0) {
                double newQuantity = ingredient.getQuantity() / mOriginalAmount * newAmount;
                String newQuantityString = StringUtilities.toDisplayQuantity(newQuantity);

                bld.replace(ingredient.getQuantityPosition().getBeginIndex(),
                        ingredient.getQuantityPosition().getEndIndex(),
                        newQuantityString);
            }
        }

        mCurrentAmount = newAmount;

    }

    public static String[] extractDescriptionSteps(Recipe recipe) {
        int stepsCount = recipe.getRecipeSteps().size();
        String[] steps = new String[stepsCount];

        for (int i = 0; i < stepsCount; i++) {
            steps[i] = recipe.getRecipeSteps().get(i).getDescription();
        }
        return steps;
    }
}
